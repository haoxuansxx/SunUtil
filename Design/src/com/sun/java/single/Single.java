package single;

/**
 * 单例模式
 *
 * @Author Sun
 * @date 2019-03-05
 */
public class Single {

    /**
     * 定义：单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统
     *       中一个类只有一个实例。即一个类只有一个对象实例。
     *
     * 特点：
     *      1. 单例类只能有一个实例。
     *      2. 单例类必须自己自己创建自己的唯一实例。
     *      3. 单例类必须给所有其他对象提供这一实例。
     *
     * 单例模式的要点：
     *      1. 私有的构造方法
     *      2. 指向自己实例的私有静态引用
     *      3. 以自己实例为返回值的静态的公有的方法
     *
     * 单例模式根据实例化对象时机的不同分为两种：
     *      饿汉式单例：饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；代码参考：SingletonHungry
     *      懒汉式单例：懒汉式单例在调用取得实例方法的时候才会实例化对象。代码参考：SingletonLazy
     *
     * 单例模式的优点：
     *      1. 在内存中只有一个对象，节省内存空间。
     *      2. 避免频繁的创建销毁对象，可以提高性能。
     *      3. 避免对共享资源的多重占用。
     *      4. 可以全局访问。
     *
     * 单例模式的优点：
     *      1. 扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。
     *      2. 隐式使用引起类结构不清晰。
     *      3. 导致程序内存泄露的问题。
     *
     * 适用场景：由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：
     *      1. 需要频繁实例化然后销毁的对象。
     *      2. 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
     *      3. 资源共享的情况下，避免由于资源操作时导致的性能或损耗等
     *      4. 控制资源的情况下，方便资源之间的互相通信。
     *
     * 单例模式注意事项：
     *      1. 只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。
     *      2. 不要做断开单例类对象与类中静态引用的危险操作。
     *      3. 多线程使用单例使用共享资源时，注意线程安全问题。
     */
    public static void main(String[] args) {
        // 创建单例模式对象
        Single single = new Single();
    }

    /**
     * 单例模式还有一种比较常见的形式：双重锁的形式
     *
     * 这个模式将同步内容下方到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。
     * 这种模式中双重判断加同步的方式，比第一个例子中的效率大大提升，因为如果单层if判断，在服务器允许的情况下，假设有一百个线程，耗费的时间
     * 为100*（同步判断时间+if判断时间），而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。
     * 所以如果面对高并发的情况，而且采用的是懒汉模式，最好的选择就是双重判断加同步的方式。
     *
     * 代码参考：SingletonDoubleLock
     */

    /**
     *
     * 关于Java中单例模式的一些常见问题：
     *
     * 问题1：单例模式的对象长时间不用会被jvm垃圾收集器收集吗？
     * 答案1：
     *      除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。
     *      jvm卸载类的判定条件如下：
     *         1. 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
     *         2. 加载该类的ClassLoader已经被回收。
     *         3. 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。
     *      只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。
     *
     * 问题2：在一个jvm中会出现多个单例吗？
     * 答案2：在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，
     *        会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。
     *        代码如下：
     *        Class c = Class.forName(Singleton.class.getName());
     *        Constructor ct = c.getDeclaredConstructor();
     *        ct.setAccessible(true);
     *        Singleton singleton = (Singleton)ct.newInstance();
     *        这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。
     *
     * 问题3：在getInstance()方法上同步有优势还是仅同步必要的块更优优势？
     * 答案3：因为锁定仅仅在创建实例时才有意义，然后其他时候实例仅仅是只读访问的，因此只同步必要的块的性能更优，并且是更好的选择。
     *        缺点：只有在第一次调用的时候，才会出现生成2个对象，才必须要求同步。而一旦singleton 不为null，系统依旧花费同步锁开销，有点得不偿失。
     *
     * 问题4：单例类可以被继承吗
     * 答案4：根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。
     *        这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：
     *        登记式单例，来使得单例对继承开放。
     */

}
